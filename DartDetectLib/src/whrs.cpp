/**
 * whrs.cpp - Phase 26/27: Weighted Hypothesis Ranking Selector
 *
 * Replaces the rule-based selector in HHS with a weighted scoring system.
 * Each candidate gets a composite score; highest score wins with confidence margin guard.
 * Requires UseHHS=1 (for candidate generation) and UseWHRS=1.
 *
 * Phase 27 (DCWO): Weights configurable at runtime via feature flags.
 * When UseDCWO=1, optimized weights are used; when OFF, Phase 26 defaults.
 */
#include "dart_detect_internal.h"
#include <algorithm>
#include <cmath>
#include <vector>
#include <map>
#include <string>

// ============================================================================
// Feature Flags (default OFF)
// ============================================================================
static bool g_use_whrs = false;
static bool g_whrs_enable_score_ranking = true;
static bool g_whrs_enable_confidence_margin = true;
static bool g_whrs_allow_single_override = true;
static bool g_whrs_fallback_to_tri_if_low_conf = true;

// Phase 27: DCWO flag
static bool g_use_dcwo = false;

// Phase 26 default weights
static double g_wR = 0.30;
static double g_wI = 0.15;
static double g_wA = 0.20;
static double g_wQ = 0.10;
static double g_wB = 0.10;
static double g_wD = 0.10;
static double g_wC = 0.05;

// Phase 27: DCWO optimized weights (will be updated after optimization)
static double g_dcwo_wR = 0.30;
static double g_dcwo_wI = 0.15;
static double g_dcwo_wA = 0.20;
static double g_dcwo_wQ = 0.10;
static double g_dcwo_wB = 0.10;
static double g_dcwo_wD = 0.10;
static double g_dcwo_wC = 0.05;

int set_whrs_flag(const char* name, int value) {
    std::string s(name);
    if (s == "UseWHRS") { g_use_whrs = (value != 0); return 0; }
    if (s == "UseDCWO") { g_use_dcwo = (value != 0); return 0; }
    if (s == "WHRS_EnableScoreRanking") { g_whrs_enable_score_ranking = (value != 0); return 0; }
    if (s == "WHRS_EnableConfidenceMargin") { g_whrs_enable_confidence_margin = (value != 0); return 0; }
    if (s == "WHRS_AllowSingleOverride") { g_whrs_allow_single_override = (value != 0); return 0; }
    if (s == "WHRS_FallbackToTriIfLowConfidence") { g_whrs_fallback_to_tri_if_low_conf = (value != 0); return 0; }
    // Phase 27: DCWO weight flags (value is int, /100 -> float, e.g. 30 = 0.30)
    if (s == "WHRS_wR") { g_wR = value / 100.0; return 0; }
    if (s == "WHRS_wI") { g_wI = value / 100.0; return 0; }
    if (s == "WHRS_wA") { g_wA = value / 100.0; return 0; }
    if (s == "WHRS_wQ") { g_wQ = value / 100.0; return 0; }
    if (s == "WHRS_wB") { g_wB = value / 100.0; return 0; }
    if (s == "WHRS_wD") { g_wD = value / 100.0; return 0; }
    if (s == "WHRS_wC") { g_wC = value / 100.0; return 0; }
    return -1;
}

bool is_whrs_enabled() { return g_use_whrs; }

// ============================================================================
// Wedge boundary distance (degrees from nearest wedge wire)
// ============================================================================
static double wedge_boundary_distance_deg(double theta_deg) {
    double adjusted = std::fmod(theta_deg - 90.0 + 9.0 + 360.0, 360.0);
    double within_wedge = std::fmod(adjusted, 18.0);
    return std::min(within_wedge, 18.0 - within_wedge);
}

// ============================================================================
// WHRS Score Computation
// ============================================================================

struct WhrsScore {
    double R_score = 0;
    double I_score = 0;
    double A_score = 0;
    double Q_score = 0;
    double B_score = 0;
    double D_penalty = 0;
    double C_penalty = 0;
    double total = 0;
};

static WhrsScore compute_whrs_score(
    double weighted_median_residual,
    int inlier_camera_count,
    int axis_support_count,
    double sum_qi,
    double wedge_boundary_dist_deg,
    double radial_delta_from_tri,
    double camera_theta_spread_deg)
{
    WhrsScore ws;

    // Residuals are in normalized board space (~0.01 units), scale appropriately
    ws.R_score = 1.0 / (1.0 + weighted_median_residual * 100.0);
    ws.I_score = (double)inlier_camera_count / 3.0;
    ws.A_score = std::min(1.0, (double)axis_support_count / 60.0);
    ws.Q_score = std::min(1.0, sum_qi / 2.0);
    ws.B_score = std::min(1.0, std::max(0.0, wedge_boundary_dist_deg / 9.0));
    ws.D_penalty = std::exp(-radial_delta_from_tri * 10.0);
    ws.C_penalty = std::exp(-camera_theta_spread_deg / 180.0);

    ws.total = g_wR * ws.R_score
             + g_wI * ws.I_score
             + g_wA * ws.A_score
             + g_wQ * ws.Q_score
             + g_wB * ws.B_score
             + g_wD * ws.D_penalty
             + g_wC * ws.C_penalty;

    return ws;
}

// ============================================================================
// Extern: HHS candidate data (from hhs.cpp)
// We need access to the candidates generated by HHS. We'll use a shared
// vector that HHS populates and WHRS reads.
// ============================================================================

// HhsCandidateExport moved to dart_detect_internal.h

// Get wedge index (duplicated from hhs.cpp for locality)
static int whrs_get_wedge_index(const Point2f& p) {
    double angle_rad = std::atan2(p.y, -p.x);
    double angle_deg = angle_rad * 180.0 / CV_PI;
    if (angle_deg < 0) angle_deg += 360.0;
    angle_deg = std::fmod(angle_deg, 360.0);
    double adjusted = std::fmod(angle_deg - 90.0 + 9.0 + 360.0, 360.0);
    return ((int)(adjusted / 18.0)) % 20;
}

// ============================================================================
// Main WHRS Selection
// ============================================================================

std::optional<IntersectionResult> whrs_select(
    const IntersectionResult& tri_result,
    const std::map<std::string, DetectionResult>& camera_results,
    const std::map<std::string, CameraCalibration>& calibrations)
{
    if (!g_use_whrs || !g_whrs_enable_score_ranking) return std::nullopt;

    // Need HHS candidates
    if (g_hhs_candidates.empty()) return std::nullopt;

    int baseline_wedge = g_hhs_baseline_wedge;

    // Compute camera theta spread for C_penalty
    // Use warped direction angles from camera data
    double camera_spread = 0.0;
    {
        std::vector<double> cam_angles;
        for (const auto& [cam_id, det] : camera_results) {
            if (!det.pca_line || !det.tip) continue;
            auto cal_it = calibrations.find(cam_id);
            if (cal_it == calibrations.end()) continue;
            const TpsTransform& tps = cal_it->second.tps_cache;
            if (!tps.valid) continue;
            Point2f wp = warp_point(tps, det.tip->x, det.tip->y);
            double a = std::atan2(wp.y, -wp.x) * 180.0 / CV_PI;
            if (a < 0) a += 360.0;
            cam_angles.push_back(a);
        }
        if (cam_angles.size() >= 2) {
            std::sort(cam_angles.begin(), cam_angles.end());
            for (size_t i = 1; i < cam_angles.size(); i++)
                camera_spread = std::max(camera_spread, cam_angles[i] - cam_angles[i-1]);
            camera_spread = std::max(camera_spread,
                360.0 - cam_angles.back() + cam_angles.front());
        }
    }

    // Score all candidates
    struct ScoredCandidate {
        int idx;
        WhrsScore ws;
        const HhsCandidateExport* cand;
    };
    std::vector<ScoredCandidate> scored;

    for (int i = 0; i < (int)g_hhs_candidates.size(); i++) {
        const auto& c = g_hhs_candidates[i];

        // If single override not allowed, skip singles
        if (!g_whrs_allow_single_override && c.type.substr(0, 7) == "single_")
            continue;

        double wb_dist = wedge_boundary_distance_deg(c.theta_deg);
        WhrsScore ws = compute_whrs_score(
            c.weighted_median_residual,
            c.inlier_camera_count,
            c.axis_support_count,
            c.sum_qi,
            wb_dist,
            c.radial_delta_from_tri,
            camera_spread
        );

        scored.push_back({i, ws, &c});
    }

    if (scored.empty()) return std::nullopt;

    // Sort by total score descending
    std::sort(scored.begin(), scored.end(),
        [](const auto& a, const auto& b) { return a.ws.total > b.ws.total; });

    const auto& best = scored[0];

    // Confidence margin guard
    if (g_whrs_enable_confidence_margin && scored.size() >= 2) {
        double ratio = best.ws.total / (scored[1].ws.total + 1e-12);
        if (ratio < 1.05) {
            // Too close - fallback to tri (conservative)
            return std::nullopt;
        }
    }

    // Low confidence fallback
    if (g_whrs_fallback_to_tri_if_low_conf && best.ws.total < 0.40) {
        return std::nullopt;
    }

    // Wedge guard: only allow +-1 step from baseline
    int sel_wedge = whrs_get_wedge_index(best.cand->coords);
    int wedge_diff = std::abs(sel_wedge - baseline_wedge);
    if (wedge_diff > 10) wedge_diff = 20 - wedge_diff;
    if (wedge_diff > 1) {
        return std::nullopt;
    }

    // If best is tri, no override needed
    if (best.cand->type == "tri") return std::nullopt;

    // Build override result
    IntersectionResult result = tri_result;
    result.coords = best.cand->coords;
    result.segment = best.cand->score.segment;
    result.multiplier = best.cand->score.multiplier;
    result.score = best.cand->score.score;
    result.method = "WHRS_" + best.cand->type;

    // Debug info
    if (result.tri_debug) {
        auto& td = *result.tri_debug;
        td.hhs_applied = true;
        td.hhs_selected_type = "WHRS_" + best.cand->type;
        td.hhs_selection_reason = "whrs_score_ranking";
        td.hhs_candidate_count = (int)g_hhs_candidates.size();
        td.hhs_baseline_wedge = baseline_wedge;
        td.hhs_selected_wedge = sel_wedge;
        td.hhs_selected_residual = best.cand->weighted_median_residual;
        td.hhs_selected_axis_support = best.cand->axis_support_count;
        td.hhs_selected_qi = best.cand->max_qi;
    }

    return result;
}
